// ============================================
// MAKALAH AI: UI Component Adapters for Persona Integration
// ============================================
// Task P07.3 Implementation: Component adapters untuk persona compatibility
// Created: August 2025
// Features: Context adapters, error boundaries, state bridging

import { createContext, useContext, ReactNode, ComponentType } from 'react'
import { ErrorBoundary } from 'react-error-boundary'
import type { PersonaTemplate } from '@/types/persona'
import { usePersonaContext, type PersonaContextData, type PersonaContextActions } from '@/hooks/usePersonaContext'
import { logPersonaError } from '@/lib/audit/persona-logging'

// ============================================
// PERSONA CONTEXT PROVIDER TYPES
// ============================================

export interface PersonaContextProviderValue {
  context: PersonaContextData
  actions: PersonaContextActions
  isLoading: boolean
  error: string | null
  isInitialized: boolean
}

export interface PersonaContextProviderProps {
  children: ReactNode
  sessionId?: string | null
  fallbackPersona?: PersonaTemplate
}

// ============================================
// PERSONA CONTEXT PROVIDER
// ============================================

const PersonaContext = createContext<PersonaContextProviderValue | null>(null)

export function PersonaContextProvider({ 
  children, 
  sessionId, 
  fallbackPersona 
}: PersonaContextProviderProps) {
  const personaHook = usePersonaContext(sessionId)

  const contextValue: PersonaContextProviderValue = {
    context: personaHook.context,
    actions: personaHook.actions,
    isLoading: personaHook.isLoading,
    error: personaHook.error,
    isInitialized: personaHook.isInitialized
  }

  return (
    <PersonaContext.Provider value={contextValue}>
      {children}
    </PersonaContext.Provider>
  )
}

export function usePersonaContextProvider() {
  const context = useContext(PersonaContext)
  if (!context) {
    throw new Error('usePersonaContextProvider must be used within PersonaContextProvider')
  }
  return context
}

// ============================================
// PERSONA-AWARE ERROR BOUNDARY
// ============================================

interface PersonaErrorBoundaryProps {
  children: ReactNode
  sessionId?: string | null
  fallback?: ComponentType<PersonaErrorFallbackProps>
  onError?: (error: Error, errorInfo: any) => void
}

interface PersonaErrorFallbackProps {
  error: Error
  resetErrorBoundary: () => void
  sessionId?: string | null
  personaContext?: PersonaContextData
}

function DefaultPersonaErrorFallback({ 
  error, 
  resetErrorBoundary, 
  sessionId,
  personaContext 
}: PersonaErrorFallbackProps) {
  return (
    <div className="persona-error-boundary p-4 border border-red-200 bg-red-50 dark:bg-red-900/20 dark:border-red-800 rounded-lg">
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          <svg className="w-5 h-5 text-red-600 dark:text-red-400" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
          </svg>
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="text-sm font-medium text-red-800 dark:text-red-200">
            Persona Component Error
          </h3>
          <div className="mt-2 text-sm text-red-700 dark:text-red-300">
            <p>
              Terjadi kesalahan dalam komponen persona. 
              {personaContext?.chatMode === 'casual' 
                ? ' Ada masalah dengan interface persona nih.'
                : ' An error occurred in the persona interface component.'
              }
            </p>
            <details className="mt-2">
              <summary className="cursor-pointer hover:text-red-600">
                Detail Error
              </summary>
              <pre className="mt-1 text-xs bg-red-100 dark:bg-red-800/30 p-2 rounded overflow-x-auto">
                {error.message}
              </pre>
            </details>
          </div>
          <div className="mt-3 flex gap-2">
            <button
              onClick={resetErrorBoundary}
              className="inline-flex items-center px-3 py-1 text-xs font-medium text-red-800 bg-red-100 hover:bg-red-200 dark:bg-red-800/30 dark:text-red-200 dark:hover:bg-red-800/50 rounded-md transition-colors"
            >
              {personaContext?.chatMode === 'casual' ? 'Coba Lagi' : 'Try Again'}
            </button>
            <button
              onClick={() => window.location.reload()}
              className="inline-flex items-center px-3 py-1 text-xs font-medium text-gray-600 bg-gray-100 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700 rounded-md transition-colors"
            >
              {personaContext?.chatMode === 'casual' ? 'Refresh Page' : 'Reload Page'}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

export function PersonaErrorBoundary({
  children,
  sessionId,
  fallback: CustomFallback,
  onError
}: PersonaErrorBoundaryProps) {
  const handleError = (error: Error, errorInfo: any) => {
    // Log error dengan persona context
    logPersonaError(
      error,
      {
        sessionId: sessionId || undefined,
        timestamp: new Date().toISOString()
      },
      {
        errorInfo,
        component: 'PersonaErrorBoundary',
        sessionId
      },
      'error'
    )

    // Call custom error handler jika ada
    if (onError) {
      onError(error, errorInfo)
    }

    console.error('[PERSONA ERROR BOUNDARY] Component error caught:', {
      error: error.message,
      sessionId,
      stack: error.stack
    })
  }

  const FallbackComponent = CustomFallback || DefaultPersonaErrorFallback

  return (
    <ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) => (
        <PersonaContextProvider sessionId={sessionId}>
          {({ context }) => (
            <FallbackComponent
              error={error}
              resetErrorBoundary={resetErrorBoundary}
              sessionId={sessionId}
              personaContext={context}
            />
          )}
        </PersonaContextProvider>
      )}
      onError={handleError}
    >
      {children}
    </ErrorBoundary>
  )
}

// ============================================
// PERSONA-AWARE COMPONENT WRAPPER
// ============================================

interface PersonaAwareComponentProps {
  sessionId?: string | null
  requiresPersona?: boolean
  enableErrorBoundary?: boolean
  className?: string
  children: (props: {
    context: PersonaContextData
    actions: PersonaContextActions
    isLoading: boolean
    error: string | null
    isInitialized: boolean
  }) => ReactNode
}

export function PersonaAwareComponent({
  sessionId,
  requiresPersona = false,
  enableErrorBoundary = true,
  className = '',
  children
}: PersonaAwareComponentProps) {
  const personaHook = usePersonaContext(sessionId)

  const content = (
    <div className={`persona-aware-component ${className}`}>
      {children({
        context: personaHook.context,
        actions: personaHook.actions,
        isLoading: personaHook.isLoading,
        error: personaHook.error,
        isInitialized: personaHook.isInitialized
      })}
    </div>
  )

  // Wrap dengan error boundary jika enabled
  if (enableErrorBoundary) {
    return (
      <PersonaErrorBoundary sessionId={sessionId}>
        {content}
      </PersonaErrorBoundary>
    )
  }

  return content
}

// ============================================
// HOC FOR PERSONA INTEGRATION
// ============================================

interface WithPersonaContextOptions {
  requiresPersona?: boolean
  enableErrorBoundary?: boolean
  sessionIdProp?: string
}

export function withPersonaContext<P extends object>(
  WrappedComponent: ComponentType<P>,
  options: WithPersonaContextOptions = {}
) {
  const {
    requiresPersona = false,
    enableErrorBoundary = true,
    sessionIdProp = 'sessionId'
  } = options

  const PersonaEnhancedComponent = (props: P & { [key: string]: any }) => {
    const sessionId = props[sessionIdProp] || null
    const personaHook = usePersonaContext(sessionId)

    // Check if persona is required but not available
    if (requiresPersona && !personaHook.context.currentPersona && personaHook.isInitialized) {
      return (
        <div className="persona-required-notice p-4 border border-yellow-200 bg-yellow-50 dark:bg-yellow-900/20 dark:border-yellow-800 rounded-lg">
          <div className="flex items-center gap-2">
            <svg className="w-5 h-5 text-yellow-600 dark:text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
            <p className="text-sm font-medium text-yellow-800 dark:text-yellow-200">
              Persona Diperlukan
            </p>
          </div>
          <p className="mt-2 text-sm text-yellow-700 dark:text-yellow-300">
            Komponen ini memerlukan persona yang aktif untuk berfungsi dengan baik.
          </p>
        </div>
      )
    }

    // Enhanced props dengan persona context
    const enhancedProps = {
      ...props,
      personaContext: personaHook.context,
      personaActions: personaHook.actions,
      personaLoading: personaHook.isLoading,
      personaError: personaHook.error,
      personaInitialized: personaHook.isInitialized
    }

    const component = <WrappedComponent {...enhancedProps} />

    // Wrap dengan error boundary jika enabled
    if (enableErrorBoundary) {
      return (
        <PersonaErrorBoundary sessionId={sessionId}>
          {component}
        </PersonaErrorBoundary>
      )
    }

    return component
  }

  // Set display name for debugging
  PersonaEnhancedComponent.displayName = 
    `withPersonaContext(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`

  return PersonaEnhancedComponent
}

// ============================================
// UTILITY ADAPTERS
// ============================================

/**
 * Adapter untuk convert persona context ke component props
 */
export function createPersonaPropsAdapter<T extends object>(
  mapPersonaToProps: (context: PersonaContextData, actions: PersonaContextActions) => T
) {
  return function usePersonaProps(sessionId?: string | null): T {
    const { context, actions } = usePersonaContext(sessionId)
    return mapPersonaToProps(context, actions)
  }
}

/**
 * Adapter untuk conditional rendering based on persona state
 */
export function createPersonaConditional(
  condition: (context: PersonaContextData) => boolean
) {
  return function PersonaConditional({ 
    children, 
    fallback = null, 
    sessionId 
  }: {
    children: ReactNode
    fallback?: ReactNode
    sessionId?: string | null
  }) {
    const { context } = usePersonaContext(sessionId)
    
    return condition(context) ? <>{children}</> : <>{fallback}</>
  }
}

// ============================================
// SPECIALIZED ADAPTERS
// ============================================

/**
 * Adapter untuk language-specific content
 */
export const PersonaLanguageAdapter = createPersonaConditional(
  (context) => context.uiConfig.preferredLanguage === 'formal'
)

/**
 * Adapter untuk mode-specific content
 */
export const PersonaFormalModeAdapter = createPersonaConditional(
  (context) => context.chatMode === 'formal'
)

export const PersonaCasualModeAdapter = createPersonaConditional(
  (context) => context.chatMode === 'casual'
)

/**
 * Adapter untuk workflow-aware content
 */
export const PersonaWorkflowAdapter = createPersonaConditional(
  (context) => context.workflowContext.isActive
)

/**
 * Props adapter untuk common UI patterns
 */
export const usePersonaUIProps = createPersonaPropsAdapter((context, actions) => ({
  chatMode: context.chatMode,
  personaName: context.currentPersona?.name || 'No Persona',
  isCompact: context.uiConfig.compactMode,
  showIndicator: context.uiConfig.showPersonaIndicator,
  language: context.uiConfig.preferredLanguage,
  onSwitchMode: actions.switchChatMode,
  onToggleCompact: () => actions.updateUIConfig({ 
    compactMode: !context.uiConfig.compactMode 
  })
}))

/**
 * Props adapter untuk workflow-related components
 */
export const usePersonaWorkflowProps = createPersonaPropsAdapter((context, actions) => ({
  isWorkflowActive: context.workflowContext.isActive,
  currentPhase: context.workflowContext.currentPhase,
  totalPhases: context.workflowContext.totalPhases,
  workflowType: context.workflowContext.workflowType,
  chatMode: context.chatMode,
  personaMode: context.currentPersona?.mode || null
}))

// ============================================
// EXPORTS
// ============================================

export {
  PersonaContext,
  PersonaContextProvider,
  usePersonaContextProvider,
  PersonaErrorBoundary,
  PersonaAwareComponent,
  withPersonaContext,
  createPersonaPropsAdapter,
  createPersonaConditional,
  PersonaLanguageAdapter,
  PersonaFormalModeAdapter,
  PersonaCasualModeAdapter,
  PersonaWorkflowAdapter,
  usePersonaUIProps,
  usePersonaWorkflowProps
}